{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#how-to-get-aquilify","title":"How to get AQUILIFY","text":"<p>Aquilify is available open-source under the BSD license. We recommend using the latest version of Python 3. The last version to support Python 2.7 is Aquilify 1.14 LTS. See the FAQ for the Python versions supported by each version of Aquilify. Here\u2019s how to get it:</p>"},{"location":"#option-1-get-the-latest-official-version","title":"Option 1: Get the latest official version","text":"<p>The latest official version is 1.14 Read the 1.14 release notes, then install it with pip:</p> <pre><code>pip install aquilify==1.14\n</code></pre>"},{"location":"#option-2-get-the-latest-development-version","title":"Option 2: Get the latest development version","text":"<p>The latest and greatest Aquilify version is the one that\u2019s in our Git repository (our revision-control system). This is only for experienced users who want to try incoming changes and help identify bugs before an official release. Get it using this shell command, which requires Git:</p> <pre><code>git clone https://github.com/embrake/aquilify.git\n</code></pre> <p>You can also download a gzipped tarball of the development version. This archive is updated every time we commit code.</p>"},{"location":"#why-choose-aquilify","title":"Why Choose Aquilify?","text":"<p>Aquilify was selected for its comprehensive support for asynchronous web application development in Python. Its key features, including robust HTTP request handling, WebSocket support, middleware capabilities, and exceptional exception handling, align perfectly with the project's requirements. The simplicity of defining routes, coupled with its scalability and community support, made Aquilify the ideal choice for empowering the development of modern, high-performance web applications.</p>"},{"location":"curd/","title":"Curd-Tutorial","text":"<p>A basic <code>CURD</code> operation using <code>aquilify.orm</code> &amp; <code>electrus</code> database.</p> <p>In this tutorial we perform a <code>CURD</code> operation <code>Create</code>, <code>Update</code>, <code>Read</code>, <code>Delete</code>.</p> <p>Technology we use :</p> <ul> <li>BACKEND: <code>AQUILIFY</code></li> <li>DATABASE: <code>AQUILIFY-ORM(Sqlite3)</code> &amp; <code>ELECTRUS(Nosql)</code></li> <li>TYPE: <code>REST-API</code></li> </ul>"},{"location":"curd/#creating-a-new-user","title":"Creating a new user","text":""},{"location":"curd/#sqlite3-database","title":"<code>sqlite3</code> database","text":"<p>Create a new app :</p> <p><pre><code>$ aquilify create-app sql-rest\n\n$ cd sql-rest/\n\n$ aquilify runserver\n</code></pre> <code>http://loaclhost:8000/</code></p> <p> </p> <p>Let's create models for our API</p> <p><code>sql-rest/models.py</code></p> <pre><code>from aquilify.orm.sqlite3 import Table\n\nfrom aquilify.orm.fields import PrimaryKeyField, VarCharField, IntegerField\n\nclass User(Table):\n    __tablename__ = 'users'\n\n    id = PrimaryKeyField( )\n    ssid = IntegerField( )\n    name = VarCharField( max_length = 255 )\n    email = VarCharField( max_length = 255 )\n    password = VarCharField( max_length = 255 )\n</code></pre> <p>Now, we have to register our model To register models we have to add some configuration in <code>settings.py</code></p>"},{"location":"curd/#settingspy","title":"settings.py","text":"<pre><code>DATABASE = {\n    \"default\": {\n        \"ENGINE\": \"aquilify.orm.Sqlite3\",\n        \"NAME\": BASE_DIR / \"db.sqlite3\",\n        \"MODELS\": [\n            \"models.User\"\n        ]\n    }\n}\n</code></pre> <p>Info</p> <p>In according to register <code>modles</code> you have to update the DATABASE -&gt; Dict[Dict[str, str]], <code>MODELS</code> list inside the <code>default</code> dict, add all the models dotted <code>path</code> inside the <code>MODELS</code> list.</p> <p>Current only <code>default</code> dict supported if you pass any other dict it cause errors! <pre><code>DATABASE = {\n    \"other\": {\n\n    }\n}\n</code></pre></p> <p>Aquilify only support's <code>sqlite3</code> &amp; <code>electrus</code> databse till now, it will be extend in future.</p> <p>Now open your terminal and run the following command to register your <code>model</code>.</p> <p>Move to the <code>project</code> directory before you run the command : <code>sql-rest</code></p> <pre><code>$ python tools.py makeporting\n</code></pre> <ul> <li>Output :</li> </ul> <pre><code>1. Model 'User' initiated successfully... 200\n\n1. Model 'User' Applied successfully... 200\n</code></pre> <p>Now let's define dynamic views &amp; routing</p> <p>create a new folder <code>api</code> -&gt; <code>sql-rest/api</code> add the following files inside <code>api</code></p> <pre><code>sql-rest/\n    api/\n        __init__.py\n        views.py\n        routing.py\n</code></pre>"},{"location":"curd/#viewpy","title":"view.py","text":"<p>Import all the neccessary modules</p> <pre><code>from typing import (\n    Dict,\n    Union\n)\n\nfrom aquilify.utils.eid import eid\nfrom aquilify.wrappers import Request\nfrom aquilify.responses import JsonResponse\nfrom aquilify.orm import LocalSessionManager\nfrom aquilify.security.crypter import hashpw\nfrom aquilify.decorators.http import require_http_method\nfrom aquilify.wrappers.reqparser import Reqparser, ReqparserError\nfrom aquilify.core.backend.validator import Schema, fields, FieldValidationError\n\nimport models\n</code></pre> <p>Now we have to define a <code>Schema</code> for user data <code>validation</code> and <code>serilization</code></p> <pre><code>class UserRegistration(Schema):\n    name: str = fields.String(required=True, max_length=50)\n    email: str = fields.Email(required=True)\n    password: str = fields.Password(required=True, min_length=8)\n</code></pre> <p>Let's define our <code>insertview</code> function</p> <pre><code>@require_http_method([\"GET\", \"POST\"])\nasync def insertview(request: Request, parser: Reqparser) -&gt; JsonResponse:\n</code></pre> <p>Info</p> <p>The require_http_method is a decorator it ensure the incoming <code>http</code> method is allowed or not! <pre><code>@require_http_method([\"GET\", \"POST\"])\n\n# Arguments:\n\nrequire_http_method(methods: AllowedMethods, error_handler: ErrorHandler = None)\n\nErrorHandler = Union[Callable[[Request], str], Awaitable[Callable[[Request], str]]]\nAllowedMethods = Union[List[str], Dict[str, List[str]]]\n</code></pre></p> <p>Adding <code>request parser</code> to paser and check all the incoming request data</p> <pre><code>if request.method == 'POST':\n    parser.add_argument('name', required=True, location='json', type=str)\n    parser.add_argument('email', required=True, location='json', type=str)\n    parser.add_argument('password', required=True, location='json', type=str)\n</code></pre>"},{"location":"curd/#creating-user-logic","title":"Creating user logic","text":"<pre><code>@require_http_method([\"GET\", \"POST\"])\nasync def insertview(request: Request, parser: Reqparser) -&gt; JsonResponse:\n    if request.method == 'POST':\n        parser.add_argument('name', required=True, location='json', type=str)\n        parser.add_argument('email', required=True, location='json', type=str)\n        parser.add_argument('password', required=True, location='json', type=str)\n\n        try:\n            parsed_data: Dict[str, str] = await UserRegistration().loads(await parser.parse(request))\n            response = await create_user(parsed_data)\n            return response\n\n        except (ReqparserError, FieldValidationError) as e:\n            return JsonResponse({\"error\": str(e)})\n\n    return JsonResponse({\n        \"response\": f\"{request.method} Method isn't supported!\",\n        \"status\": 405\n    })\n</code></pre>"},{"location":"curd/#create_user","title":"create_user","text":"<pre><code>async def create_user(data: Dict[str, str]) -&gt; Union[JsonResponse, None]:\n    try:\n        password_hash = hashpw(data.get('password'))\n        ssid = eid.random(11)\n\n        with LocalSessionManager() as session:\n            if not session.exists(models.User.email == data.get('email')):\n                user = models.User(\n                    ssid=ssid,\n                    name=data.get('name'),\n                    email=data.get('email'),\n                    password=password_hash\n                )\n                query = session.insert(user)\n\n                if not query:\n                    return JsonResponse({\"response\": \"Internal server error! ERR::9511:DB_SQLITE3::\"})\n\n                return JsonResponse({\n                    \"response\": f\"Congrats! {data.get('name')}, your account has been successfully created!\",\n                    \"ssid\": ssid,\n                    \"status\": \"Active\"\n                })\n            return JsonResponse(\n                {\n                    'response': \"User with the email {} already exists.\".format(data.get('email'))\n                }\n            )\n\n    except FieldValidationError as fex:\n        return fex.json\n    except Exception as e:\n        return JsonResponse({\"error\": str(e)})\n</code></pre>"},{"location":"curd/#complete-insertview-code","title":"Complete <code>insertview</code> code","text":"<pre><code>from typing import (\n    Dict,\n    Union\n)\n\nfrom aquilify.utils.eid import eid\nfrom aquilify.wrappers import Request\nfrom aquilify.responses import JsonResponse\nfrom aquilify.orm import LocalSessionManager\nfrom aquilify.security.crypter import hashpw\nfrom aquilify.decorators.http import require_http_method\nfrom aquilify.wrappers.reqparser import Reqparser, ReqparserError\nfrom aquilify.core.backend.validator import (Schema, fields, FieldValidationError)\n\nimport models\n\nclass UserRegistration(Schema):\n    name: str = fields.String(required=True, max_length=50)\n    email: str = fields.Email(required=True)\n    password: str = fields.Password(required=True, min_length=8)\n\nasync def create_user(data: Dict[str, str]) -&gt; Union[JsonResponse, None]:\n    try:\n        password_hash = hashpw(data.get('password'))\n        ssid = eid.random(11)\n\n        with LocalSessionManager() as session:\n            if not session.exists(models.User.email == data.get('email')):\n                user = models.User(\n                    ssid=ssid,\n                    name=data.get('name'),\n                    email=data.get('email'),\n                    password=password_hash\n                )\n                query = session.insert(user)\n\n                if not query:\n                    return JsonResponse({\"response\": \"Internal server error! ERR::9511:DB_SQLITE3::\"})\n\n                return JsonResponse({\n                    \"response\": f\"Congrats! {data.get('name')}, your account has been successfully created!\",\n                    \"ssid\": ssid,\n                    \"status\": \"Active\"\n                })\n            return JsonResponse(\n                {\n                    'response': \"User with the email {} already exists.\".format(data.get('email'))\n                }\n            )\n\n    except FieldValidationError as fex:\n        return fex.json\n    except Exception as e:\n        return JsonResponse({\"error\": str(e)})\n\n@require_http_method([\"GET\", \"POST\"])\nasync def insertview(request: Request, parser: Reqparser) -&gt; JsonResponse:\n    if request.method == 'POST':\n        parser.add_argument('name', required=True, location='json', type=str)\n        parser.add_argument('email', required=True, location='json', type=str)\n        parser.add_argument('password', required=True, location='json', type=str)\n\n        try:\n            parsed_data: Dict[str, str] = await UserRegistration().loads(await parser.parse(request))\n            response = await create_user(parsed_data)\n            return response\n\n        except (ReqparserError, FieldValidationError) as e:\n            return JsonResponse({\"error\": str(e)})\n\n    return JsonResponse({\n        \"response\": f\"{request.method} Method isn't supported!\",\n        \"status\": 405\n    })\n</code></pre>"},{"location":"curd/#setup-routing","title":"Setup routing","text":"<p><code>sql-rest/api/routing.py</code></p> <pre><code>from aquilify.core.schematic.routing import rule\n\nfrom . import view\n\nROUTER = [\n    rule('/register', view.insertview, methods = ['GET', 'POST'])\n]\n</code></pre> <p><code>sql-rest/routing.py</code></p> <pre><code>from aquilify.core.routing import rule, include\n\nimport views\n\nROUTER = [\n    rule('/api', include = include(\"api.routing\"), methods = ['GET', 'POST'])\n]\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#quick-installation-guide","title":"Quick Installation Guide \u00b6","text":"<p>Before you can use Aquilify, you\u2019ll need to get it installed. We have a complete installation guide that covers all the possibilities; this guide will guide you to a minimal installation that\u2019ll work while you walk through the introduction.</p>"},{"location":"installation/#install-python","title":"Install Python \u00b6","text":"<p>Being a Python web framework, Aquilify requires Python. See What Python version can I use with Aquilify? for details. Python includes a lightweight database called SQLite so you won\u2019t need to set up a database just yet.</p> <p>Get the latest version of Python at https://www.python.org/downloads/ or with your operating system\u2019s package manager.</p> <p>You can verify that Python is installed by typing python from your shell; you should see something like:</p> <pre><code>Python 3.x.y\n[GCC 4.x] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\n</code></pre>"},{"location":"installation/#install-the-aquilify-code","title":"Install the Aquilify code \u00b6","text":"<p>Info</p> <p>Always refer to the documentation that corresponds to the version of Aquilify you\u2019re using!</p> <p>If you do either of the first two steps, keep an eye out for parts of the documentation marked new in development version. That phrase flags features that are only available in development versions of Aquilify, and they likely won\u2019t work with an official release.</p> <p>Installation instructions are slightly different depending on whether you\u2019re installing a distribution-specific package, downloading the latest official release, or fetching the latest development version.</p> <ul> <li> <p>Install pip. The easiest is to use the standalone pip installer. If your distribution already has pip installed, you might need to update it if it\u2019s outdated. If it\u2019s outdated, you\u2019ll know because installation won\u2019t work.</p> </li> <li> <p>Take a look at venv. This tool provides isolated Python environments, which are more practical than installing packages systemwide. It also allows installing packages without administrator privileges. The contributing tutorial walks through how to create a virtual environment.</p> </li> <li> <p>After you\u2019ve created and activated a virtual environment, enter the command:</p> </li> </ul> <pre><code>$ python -m pip install aquilify\n</code></pre>"},{"location":"installation/#verifying","title":"Verifying \u00b6","text":"<p>To verify that Aquilify can be seen by Python, type <code>aquilify -v or --version</code> in you shell:</p> <p><pre><code>&gt;&gt;&gt; aquilify --version\n1.14\n</code></pre> You may have another version of Aquilify installed.</p>"},{"location":"installation/#thats-it","title":"That\u2019s it! \u00b6","text":"<p>That\u2019s it \u2013 you can now move onto the tutorial.</p>"},{"location":"middleware/","title":"Middleware","text":"<p>Aquilify includes several middleware classes for adding behavior that is applied across your entire application. These are all implemented as standard ASGI middleware classes, and can be applied either to Aquilify or to any other ASGI application.</p>"},{"location":"middleware/#using-middleware","title":"Using Middleware","text":"<p>The Aquilify application class allows you to include the ASGI middleware in a way that ensures that it remains wrapped by the exception handler.</p> <p>Setup and new project using <code>aquilify create-app</code> called <code>mdls</code></p> <p>Info</p> <p><code>Aquilify</code> comes with some default <code>middlewares</code> integrated. <pre><code>MIDDLEWARES = [\n    \"aquilify.middlewares.XFrameOptionsMiddleware\",\n    \"aquilify.middlewares.GzipMiddleware\",\n    \"aquilify.middlewares.StaticMiddleware\",\n    \"aquilify.middlewares.TrustedhostMiddleware\",\n    \"aquilify.middlewares.CSRFMiddleware\",\n    \"aquilify.middlewares.MediaMiddleware\",\n    \"aquilify.middlewares.ConditionalGetMiddleware\",\n    \"aquilify.core.messages.middleware.MessageMiddleware\",\n]\n</code></pre></p>"},{"location":"middleware/#usage","title":"Usage","text":"<p>To implement a middleware class, you must override the <code>async def dispatch(request, response)</code> method.</p> <p>Create a new directory <code>middleware</code> <code>mdls/middleware</code> and the the <code>__init__.py</code> then create a file <code>logging.py</code>.</p> <p><code>logging.py</code> <pre><code>class LoggingMiddleware:\n    def __init__(self):\n        pass\n\n    async def __call__(self, request, response):\n        log = \"Request Found from {}, Method: {}, Status: {}\".format(\n        request.url,\n        request.method,\n        response.status_code\n    )\n        print(log)\n        return response # -&gt; Object(Response)\n</code></pre> Now update the <code>settings.py</code> with the <code>LoggingMiddleware</code>.</p> <p><pre><code>MIDDLEWARES = [\n    \"aquilify.middlewares.XFrameOptionsMiddleware\",\n    \"aquilify.middlewares.GzipMiddleware\",\n    \"aquilify.middlewares.StaticMiddleware\",\n    \"aquilify.middlewares.TrustedhostMiddleware\",\n    \"aquilify.middlewares.CSRFMiddleware\",\n    \"aquilify.middlewares.MediaMiddleware\",\n    \"aquilify.middlewares.ConditionalGetMiddleware\",\n    \"aquilify.core.messages.middleware.MessageMiddleware\",\n    \"middleware.logging.LoggingMiddleware\"\n]\n</code></pre> Add the <code>LoggingMiddleware</code> instance the <code>MIDDLEWARES</code> list, the <code>Aquilify</code> automatically get the <code>LoggingMiddleware</code> instace from it's path and add it in <code>middleware</code> executor.</p> <p>Warning</p> <p>Currently Middleware are only support to interfare with the response if you try to refactor the <code>before request</code> if can't be possible. <pre><code>async def mymiddleware(request, response):\n    # request.name = 'test' this thing isn't possbile till now.\n    response.status_code = 200 # you can make further changes `after the response`.\n    retun response\n    # the response object already taken the request so you must have to return the `response` to next `middleware` or next `handler`.\n</code></pre> but we have a better and even more powerful solution for this error you can try out own <code>Stage Hanlders</code> which can able to refactor the <code>before request</code> &amp; <code>after response</code>. <pre><code>class BeforeRequestStageHandler:\n    def __init__(self):\n        pass\n\n    async def __call__(self, request):\n        request.name = 'test'\n        request.url = 'http://localhost:8000'\n</code></pre> You can interect with the <code>before request</code> with the help of StageHandlers the complete documantation available at StageHandlers.</p>"},{"location":"middleware/#pure-asgi-middleware","title":"Pure ASGI Middleware","text":"<p>The ASGI spec makes it possible to implement ASGI middleware using the ASGI interface directly, as a chain of ASGI applications that call into the next one. In fact, this is how middleware classes shipped with Aquilify are implemented.</p>"},{"location":"middleware/#writing-pure-asgi-middleware","title":"Writing pure ASGI middleware","text":"<p>The most common way to create an ASGI middleware is with a class.</p> <p><code>mdls/middleware/asgi_middleware.py</code></p> <pre><code>class ASGIMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        await self.app(scope, receive, send)\n</code></pre> <p>The middleware above is the most basic ASGI middleware. It receives a parent ASGI application as an argument for its constructor, and implements an <code>async __call__</code> method which calls into that parent application.</p> <p><code>mdls/settings.py</code></p> <pre><code>MIDDLEWARES = [\n    \"aquilify.middlewares.XFrameOptionsMiddleware\",\n    \"aquilify.middlewares.GzipMiddleware\",\n    \"aquilify.middlewares.StaticMiddleware\",\n    \"aquilify.middlewares.TrustedhostMiddleware\",\n    \"aquilify.middlewares.CSRFMiddleware\",\n    \"aquilify.middlewares.MediaMiddleware\",\n    \"aquilify.middlewares.ConditionalGetMiddleware\",\n    \"aquilify.core.messages.middleware.MessageMiddleware\",\n    {\n        \"origin\": \"middleware.asgi_middleware.ASGIMiddleware\",\n        \"__init__\": \"app\",\n        \"order\": 6\n    }\n]\n</code></pre>"},{"location":"middleware/#aquilify-dynamic-middleware-configuration","title":"Aquilify Dynamic Middleware Configuration","text":"<p>Aquilify offers a robust dynamic middleware configuration catering to middleware that overrides application behavior, such as the <code>ASGIMiddleware</code>. This specialized middleware, operating as a pure <code>ASGI</code> Middleware, initializes the app instance.</p> <p>When configuring a dict within the <code>MIDDLEWARES</code> list, provide a key named <code>origin</code>, specifying the path to the middleware. If your middleware requires access to the current app instance through its <code>__init__</code> method, include an argument for <code>app</code>. By setting up the <code>__init__</code> key as app within the <code>MIDDLEWARES</code> list of type <code>List[Dict]</code>, <code>Aquilify</code> automatically passes the current <code>app</code> instance to facilitate seamless integration.</p>"},{"location":"middleware/#decorator-style-middleware-configuration","title":"Decorator style Middleware Configuration","text":"<pre><code>import functools\n\ndef asgi_middleware():\n    def asgi_decorator(app):\n\n        @functools.wraps(app)\n        async def wrapped_app(scope, receive, send):\n            await app(scope, receive, send)\n\n        return wrapped_app\n\n    return asgi_decorator\n</code></pre> <p>In any case, ASGI middleware must be callables that accept three arguments: <code>scope</code>, <code>receive</code>, and <code>send</code>.</p> <ul> <li><code>scope</code> is a dict holding information about the connection, where <code>scope[\"type\"]</code> may be:<ul> <li><code>\"http\"</code>: for HTTP requests.</li> <li><code>\"websocket\"</code>: for WebSocket connections.</li> <li><code>\"lifespan\"</code>: for ASGI lifespan messages.</li> </ul> </li> <li><code>receive</code> and <code>send</code> can be used to exchange ASGI event messages with the ASGI server \u2014 more on this below. The type and contents of these messages depend on the scope type. Learn more in the ASGI specification.</li> </ul>"},{"location":"middleware/#type-annotations","title":"Type annotations","text":"<p>There are two ways of annotating a middleware: using Aquilify itself or <code>asgiref</code>.</p> <ul> <li>Using Aquilify: for most common use cases.</li> </ul> <pre><code>from aquilify.types import ASGIApp, Message, Scope, Receive, Send\n\n\nclass ASGIMiddleware:\n    def __init__(self, app: ASGIApp) -&gt; None:\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        async def send_wrapper(message: Message) -&gt; None:\n            # ... Do something\n            await send(message)\n\n        await self.app(scope, receive, send_wrapper)\n</code></pre> <ul> <li>Using <code>asgiref</code>: for more rigorous type hinting.</li> </ul> <pre><code>from asgiref.typing import ASGI3Application, ASGIReceiveCallable, ASGISendCallable, Scope\nfrom asgiref.typing import ASGIReceiveEvent, ASGISendEvent\n\n\nclass ASGIMiddleware:\n    def __init__(self, app: ASGI3Application) -&gt; None:\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -&gt; None:\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        async def send_wrapper(message: ASGISendEvent) -&gt; None:\n            # ... Do something\n            await send(message)\n\n        return await self.app(scope, receive, send_wrapper)\n</code></pre>"},{"location":"middleware/#common-patterns","title":"Common patterns","text":""},{"location":"middleware/#processing-certain-requests-only","title":"Processing certain requests only","text":"<p>ASGI middleware can apply specific behavior according to the contents of <code>scope</code>.</p> <p>For example, to only process HTTP requests, write this...</p> <pre><code>class ASGIMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        ...  # Do something here!\n\n        await self.app(scope, receive, send)\n</code></pre> <p>Likewise, WebSocket-only middleware would guard on <code>scope[\"type\"] != \"websocket\"</code>.</p> <p>The middleware may also act differently based on the request method, URL, headers, etc.</p>"},{"location":"middleware/#reusing-aquilify-components","title":"Reusing Aquilify components","text":"<p>Aquilify provides several data structures that accept the ASGI <code>scope</code>, <code>receive</code> and/or <code>send</code> arguments, allowing you to work at a higher level of abstraction. Such data structures include <code>Request</code>, <code>Headers</code>, <code>QueryParams</code>, <code>URL</code>, etc.</p> <p>For example, you can instantiate a <code>Request</code> to more easily inspect an HTTP request:</p> <pre><code>from aquilify.wrappers import Request\n\nclass ASGIMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] == \"http\":\n            request = Request(scope)\n            ... # Use `request.method`, `request.url`, `request.headers`, etc.\n\n        await self.app(scope, receive, send)\n</code></pre> <p>You can also reuse responses, which are ASGI applications as well.</p>"},{"location":"middleware/#inspecting-or-modifying-the-request","title":"Inspecting or modifying the request","text":"<p>Request information can be accessed or changed by manipulating the <code>scope</code>. For a full example of this pattern, see Uvicorn's <code>ProxyHeadersMiddleware</code> which inspects and tweaks the <code>scope</code> when serving behind a frontend proxy.</p> <p>Besides, wrapping the <code>receive</code> ASGI callable allows you to access or modify the HTTP request body by manipulating <code>http.request</code> ASGI event messages.</p> <p>As an example, this middleware computes and logs the size of the incoming request body...</p> <pre><code>class LoggedRequestBodySizeMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        body_size = 0\n\n        async def receive_logging_request_body_size():\n            nonlocal body_size\n\n            message = await receive()\n            assert message[\"type\"] == \"http.request\"\n\n            body_size += len(message.get(\"body\", b\"\"))\n\n            if not message.get(\"more_body\", False):\n                print(f\"Size of request body was: {body_size} bytes\")\n\n            return message\n\n        await self.app(scope, receive_logging_request_body_size, send)\n</code></pre> <p>Likewise, WebSocket middleware may manipulate <code>websocket.receive</code> ASGI event messages to inspect or alter incoming WebSocket data.</p> <p>For an example that changes the HTTP request body, see <code>msgpack-asgi</code>.</p>"},{"location":"middleware/#passing-information-to-endpoints","title":"Passing information to endpoints","text":"<p>If you need to share information with the underlying app or endpoints, you may store it into the <code>scope</code> dictionary. Note that this is a convention -- for example, Aquilify uses this to share routing information with endpoints -- but it is not part of the ASGI specification. If you do so, be sure to avoid conflicts by using keys that have low chances of being used by other middleware or applications.</p> <p>For example, when including the middleware below, endpoints would be able to access <code>request.scope[\"asgi_transaction_id\"]</code>.</p> <pre><code>import uuid\n\nclass TransactionIDMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        scope[\"asgi_transaction_id\"] = uuid.uuid4()\n        await self.app(scope, receive, send)\n</code></pre>"},{"location":"middleware/#cleanup-and-error-handling","title":"Cleanup and error handling","text":"<p>You can wrap the application in a <code>try/except/finally</code> block or a context manager to perform cleanup operations or do error handling.</p> <p>For example, the following middleware might collect metrics and process application exceptions...</p> <pre><code>import time\n\nclass MonitoringMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        start = time.time()\n        try:\n            await self.app(scope, receive, send)\n        except Exception as exc:\n            ...  # Process the exception\n            raise\n        finally:\n            end = time.time()\n            elapsed = end - start\n            ...  # Submit `elapsed` as a metric to a monitoring backend\n</code></pre> <p>See also <code>timing-asgi</code> for a full example of this pattern.</p>"},{"location":"middleware/#further-reading","title":"Further reading","text":"<p>This documentation should be enough to have a good basis on how to create an ASGI middleware.</p> <p>Nonetheless, there are great articles about the subject:</p> <ul> <li>Introduction to ASGI: Emergence of an Async Python Web Ecosystem</li> <li>How to write ASGI middleware</li> </ul>"},{"location":"requests/","title":"Request","text":"<p>Aquilify includes a <code>Request</code> class that gives you a nicer interface onto the incoming request, rather than accessing the ASGI scope and receive channel directly.</p>"},{"location":"requests/#request","title":"Request","text":"<p>Signature: <code>Request(scope, receive=None)</code></p> <pre><code>from aquilify.wrappers import Request\nfrom aquilify.wrappers import Response\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    request = Request(scope, receive)\n    content = '%s %s' % (request.method, request.url.path)\n    response = Response(content, media_type='text/plain')\n    await response(scope, receive, send)\n</code></pre> <p>Requests present a mapping interface, so you can use them in the same way as a <code>scope</code>.</p> <p>For instance: <code>request['path']</code> will return the ASGI path.</p> <p>If you don't need to access the request body you can instantiate a request without providing an argument to <code>receive</code>.</p>"},{"location":"requests/#method","title":"Method","text":"<p>The request method is accessed as <code>request.method</code>.</p>"},{"location":"requests/#url","title":"URL","text":"<p>The request URL is accessed as <code>request.url</code>.</p> <p>The property is a string-like object that exposes all the components that can be parsed out of the URL.</p> <p>For example: <code>request.url.path</code>, <code>request.url.port</code>, <code>request.url.scheme</code>.</p>"},{"location":"requests/#headers","title":"Headers","text":"<p>Headers are exposed as an immutable, case-insensitive, multi-dict.</p> <p>For example: <code>request.headers['content-type']</code></p>"},{"location":"requests/#query-parameters","title":"Query Parameters","text":"<p>Query parameters are exposed as an immutable multi-dict.</p> <p>For example: <code>request.query_params['search']</code></p>"},{"location":"requests/#path-parameters","title":"Path Parameters","text":"<p>Router path parameters are exposed as a dictionary interface.</p> <p>For example: <code>request.path_params['username']</code></p>"},{"location":"requests/#client-address","title":"Client Address","text":"<p>The client's remote address is exposed as a named two-tuple <code>request.client</code>. Either item in the tuple may be <code>None</code>.</p> <p>The hostname or IP address: <code>request.client.host</code></p> <p>The port number from which the client is connecting: <code>request.client.port</code></p>"},{"location":"requests/#cookies","title":"Cookies","text":"<p>Cookies are exposed as a regular dictionary interface.</p> <p>For example: <code>request.cookies.get('mycookie')</code></p> <p>Cookies are ignored in case of an invalid cookie. (RFC2109)</p>"},{"location":"requests/#body","title":"Body","text":"<p>There are a few different interfaces for returning the body of the request:</p> <p>The request body as bytes: <code>await request.body()</code></p> <p>The request body, parsed as form data or multipart: <code>async with request.form() as form:</code></p> <p>The request body, parsed as JSON: <code>await request.json()</code></p> <p>You can also access the request body as a stream, using the <code>async for</code> syntax:</p> <pre><code>from aquilify.wrappers import Request\nfrom aquilify.wrappers import Response\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    request = Request(scope, receive)\n    body = b''\n    async for chunk in request.stream():\n        body += chunk\n    response = Response(body, media_type='text/plain')\n    await response(scope, receive, send)\n</code></pre> <p>If you access <code>.stream()</code> then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to <code>.body()</code>, <code>.form()</code>, or <code>.json()</code> will raise an error.</p> <p>In some cases such as long-polling, or streaming responses you might need to determine if the client has dropped the connection. You can determine this state with <code>disconnected = await request.is_disconnected()</code>.</p>"},{"location":"requests/#request-files","title":"Request Files","text":"<p>Request files are normally sent as multipart form data (<code>multipart/form-data</code>).</p> <p>Signature: <code>request.form(max_files=1000, max_fields=1000)</code></p> <p>You can configure the number of maximum fields or files with the parameters <code>max_files</code> and <code>max_fields</code>:</p> <pre><code>async with request.form(max_files=1000, max_fields=1000):\n    ...\n</code></pre> <p>Info</p> <p>These limits are for security reasons, allowing an unlimited number of fields or files could lead to a denial of service attack by consuming a lot of CPU and memory parsing too many empty fields.</p> <p>When you call <code>async with request.form() as form</code> you receive a <code>aquilify.datastructures.core.FormData</code> which is an immutable multidict, containing both file uploads and text input. File upload items are represented as instances of <code>aquilify.datastructures.core.UploadFile</code>.</p> <p><code>UploadFile</code> has the following attributes:</p> <ul> <li><code>filename</code>: An <code>str</code> with the original file name that was uploaded or <code>None</code> if its not available (e.g. <code>myimage.jpg</code>).</li> <li><code>content_type</code>: An <code>str</code> with the content type (MIME type / media type) or <code>None</code> if it's not available (e.g. <code>image/jpeg</code>).</li> <li><code>file</code>: A <code>SpooledTemporaryFile</code> (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object.</li> <li><code>headers</code>: A <code>Headers</code> object. Often this will only be the <code>Content-Type</code> header, but if additional headers were included in the multipart field they will be included here. Note that these headers have no relationship with the headers in <code>Request.headers</code>.</li> <li><code>size</code>: An <code>int</code> with uploaded file's size in bytes. This value is calculated from request's contents, making it better choice to find uploaded file's size than <code>Content-Length</code> header. <code>None</code> if not set.</li> </ul> <p><code>UploadFile</code> has the following <code>async</code> methods. They all call the corresponding file methods underneath (using the internal <code>SpooledTemporaryFile</code>).</p> <ul> <li><code>async write(data)</code>: Writes <code>data</code> (<code>bytes</code>) to the file.</li> <li><code>async read(size)</code>: Reads <code>size</code> (<code>int</code>) bytes of the file.</li> <li><code>async seek(offset)</code>: Goes to the byte position <code>offset</code> (<code>int</code>) in the file.<ul> <li>E.g., <code>await myfile.seek(0)</code> would go to the start of the file.</li> </ul> </li> <li><code>async close()</code>: Closes the file.</li> </ul> <p>As all these methods are <code>async</code> methods, you need to \"await\" them.</p> <p>For example, you can get the file name and the contents with:</p> <pre><code>async with request.form() as form:\n    filename = form[\"upload_file\"].filename\n    contents = await form[\"upload_file\"].read()\n</code></pre> <p>Info</p> <p>As settled in RFC-7578: 4.2, form-data content part that contains file  assumed to have <code>name</code> and <code>filename</code> fields in <code>Content-Disposition</code> header: <code>Content-Disposition: form-data; name=\"user\"; filename=\"somefile\"</code>. Though <code>filename</code> field is optional according to RFC-7578, it helps  Aquilify to differentiate which data should be treated as file. If <code>filename</code> field was supplied, <code>UploadFile</code>  object will be created to access underlying file, otherwise form-data part will be parsed and available as a raw  string.</p>"},{"location":"requests/#application","title":"Application","text":"<p>The originating Aquilify application can be accessed via <code>request.app</code>.</p>"},{"location":"response/","title":"Response","text":"<p>Aquilify includes a few response classes that handle sending back the appropriate ASGI messages on the <code>send</code> channel.</p>"},{"location":"response/#response","title":"Response","text":"<p>Signature: <code>Response(content, content_type='text/plain', status_code=200, headers=None)</code></p> <ul> <li><code>content</code> - A string or bytestring.</li> <li><code>status_code</code> - An integer HTTP status code.</li> <li><code>headers</code> - A dictionary of strings.</li> <li><code>content_type</code> - A string giving the media type. eg. \"text/html\"</li> </ul> <p>Aquilify will automatically include a Content-Length header. It will also include a Content-Type header, based on the content_type and appending a charset for text types.</p> <p>Once you've instantiated a response, you can send it by calling it as an ASGI application instance.</p> <pre><code>from aquilify.wrappers import Response\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    response = Response('Hello, world!', content_type='text/plain')\n    await response(scope, receive, send)\n</code></pre>"},{"location":"response/#set-cookie","title":"Set Cookie","text":"<p>Aquilify provides a <code>set_cookie</code> method to allow you to set cookies on the response object.</p> <p>Signature: <code>Response.set_cookie(key, value, max_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\")</code></p> <ul> <li><code>key</code> - A string that will be the cookie's key.</li> <li><code>value</code> - A string that will be the cookie's value.</li> <li><code>max_age</code> - An integer that defines the lifetime of the cookie in seconds. A negative integer or a value of <code>0</code> will discard the cookie immediately. <code>Optional</code></li> <li><code>expires</code> - Either an integer that defines the number of seconds until the cookie expires, or a datetime. <code>Optional</code></li> <li><code>path</code> - A string that specifies the subset of routes to which the cookie will apply. <code>Optional</code></li> <li><code>domain</code> - A string that specifies the domain for which the cookie is valid. <code>Optional</code></li> <li><code>secure</code> - A bool indicating that the cookie will only be sent to the server if request is made using SSL and the HTTPS protocol. <code>Optional</code></li> <li><code>httponly</code> - A bool indicating that the cookie cannot be accessed via JavaScript through <code>Document.cookie</code> property, the <code>XMLHttpRequest</code> or <code>Request</code> APIs. <code>Optional</code></li> <li><code>samesite</code> - A string that specifies the samesite strategy for the cookie. Valid values are <code>'lax'</code>, <code>'strict'</code> and <code>'none'</code>. Defaults to <code>'lax'</code>. <code>Optional</code></li> </ul>"},{"location":"response/#delete-cookie","title":"Delete Cookie","text":"<p>Conversely, Aquilify also provides a <code>delete_cookie</code> method to manually expire a set cookie.</p> <p>Signature: <code>Response.delete_cookie(key, path='/', domain=None)</code></p>"},{"location":"routing/","title":"Routing","text":""},{"location":"routing/#http-routing","title":"HTTP Routing","text":"<p>Aquilify has a roubust request routing system. A routing table is defined as a list of routes, and passed when instantiating the application.</p> <p>Due to it's comprehensive nature you must need to setup project before instantiating routing run command <code>aquilify create-app</code> to create a new project.</p> <p><code>project/views.py</code></p> <pre><code>async def home():\n    return {\"message\": \"Homepage\"}, 200\n\nasync def about():\n    return {\"message\": \"Aboutpage\"}, 200\n</code></pre> <p><code>project/routing.py</code></p> <pre><code>from aquilify.core.routing import rule\n\nfrom . import views\n\nROUTER = [\n    rule('/home', views.home, name='Home Page!'),\n    rule('/about', views.about, name='About Page!')\n]\n</code></pre>"},{"location":"routing/#aquilify-dynamic-routing-configuration","title":"Aquilify Dynamic Routing Configuration","text":"<p>Aquilify offers dynamic routing functionality, enabling the use of dynamic routing through the <code>Aquilify Schematic</code>. To implement dynamic routing, define all your views within the <code>project/app/main.py</code> file, and then utilize the <code>link</code> function in <code>routing.py</code> to establish the connection between schematics for dynamic routing.</p>"},{"location":"routing/#projectappmainpy","title":"<code>project/app/main.py</code>","text":"<p><pre><code>from aquilify.schematic import Schematic\n\nblogs = Schematic(\"My Dynamic Blogs Routing\")\n\nasync def home():\n    return {'message': 'Welcome to the Home Page for /blogs'}\n\nblogs.add_link('/', methods=['GET', 'POST'], endpoint=home)\n</code></pre> In this section, import the Schematic from <code>aquilify.schematic</code>. Create an instance\u2014named <code>blogs</code> in this example\u2014and define your views within it. Then, use the <code>add_link</code> function to associate your views with the instance.</p> <p>Info</p> <p>Schematic, within Aquilify, not only supports standard routing but also extends its functionality to include dynamic routing for WebSockets. Additionally, it includes a dedicated middleware compartment. Enabling instance.enable_middlewares = True empowers the passage of child middlewares to the parent middleware </p>"},{"location":"routing/#projectappmainpy_1","title":"<code>project/app/main.py</code>","text":"<p>Websockets configuration</p> <pre><code>from aquilify.schematic import Schematic\nfrom aquilify.wrappers import WebSocket, WebSocketDisconnect\n\nblogs = Schematic(\"My dynamic blogs routing\") \n\nasync def home():\n    return {'message': 'Welcome to /blogs Home Page'}\n\nasync def mysocket(websocket: WebSocket) -&gt; WebSocket:\n    await websocket.accept()\n    try:\n        while True:\n            data = websocket.receive_text()\n            await websocket.send_text(data)\n    except WebSocketDisconnect as e:\n        raise e\n\nblogs.add_websocket_rule('/ws', mysocket)\nblogs.add_link('/', methods=['GET', 'POST'], endpoint=home)\n</code></pre>"},{"location":"routing/#projectroutingpy","title":"<code>project/routing.py</code>","text":"<pre><code>from aquilify.core.routing import rule, link\n\nfrom . import views\n\nROUTER = [\n    rule('/home', endpoint=views.home, name='Home Page'),\n    rule('/about', endpoint=views.about, name='About Page'),\n    link( {\"/blog\": \"app.main.blogs\"} )\n]\n</code></pre> <p>In this section, import the necessary functions from <code>Aquilify</code> modules. Define routes for the parent application and utilize the link function to establish the connection between the child instance (blogs) and the parent application. The format for linking is <code>link({\"/blog\": \"app.main.blogs\"})</code>, where <code>\"/blog\"</code> denotes the URL prefix and <code>\"app.main.blogs\"</code> represents the instance path location for the blogs instance.</p>"},{"location":"routing/#aquilify-schematic-url-dynamic-routing","title":"Aquilify Schematic URL Dynamic Routing","text":"<p>Aquilify offers a another dynamic routing option which is a part of <code>schematic</code> but different it more versitile and advanced it offer's more robust and advance routing within your application.</p>"},{"location":"routing/#a-basic-example","title":"A basic example","text":"<p>create a new app called <code>myapp</code></p> <p>inside <code>myapp</code> create a new folder called <code>api</code></p> <p>inside the <code>api</code> directory create 3 files <code>__init__.py</code>, <code>routing.py</code>, <code>views.py</code></p> <p>and add the following code : <code>views.py</code></p> <pre><code>async def home() -&gt; str:\n    return \"Welcome to Aquilify advanced dynamic routing.\"\n</code></pre> <p><code>routing.py</code></p> <pre><code>from aquilify.core.schematic.routing import rule\n\nfrom . import views\n\nROUTER = [\n    rule('/', views.home)\n]\n</code></pre> <p>Warning</p> <p>Do not use the regular <code>aquilify.core.routing</code> <code>rule</code> function in the Advance routing if you done this it may cause erros and your application may not work properly. <pre><code># Do not do this :\nfrom aquilify.core.routing import rule\n\nROUTER = [\n    rule( ... )\n]\n</code></pre> if your'e using the advance dynamic routing always import the rule and other routing functions from <code>aquilify.core.schematic.routing</code></p> <pre><code># Do this :\n\nfrom aquilify.core.schematic.routing import rule\n\nROUTER = [\n    rule( ... )\n]\n</code></pre> <p>Now update the Parent <code>ROUTER</code> <code>myapp/routing.py</code></p> <p>In according to add the child <code>ROUTER</code> with your parent <code>ROUTER</code> you have to <code>include</code> it.</p> <p>import the <code>include</code> function and pass the dooted path to <code>child ROUTING</code> or <code>routing</code> file.</p> <pre><code>Args:\n    - args (str): The modules' dotted paths.\n    - namespace (str): The application namespace.\n\n    Returns:\n    - Optional[List[Any]]: The included routing configurations.\n</code></pre> <pre><code>from aquilify.core.routing import rule, include\n\nROUTER = [\n    rule('/api', include = include(\"api.routing\") )\n]\n</code></pre>"},{"location":"routing/#http-routing-functions","title":"HTTP Routing Functions","text":"<ul> <li><code>rule</code> - Define an HTTP routing rule.</li> <li><code>rule_all</code> - Define an HTTP routing rule for all methods.</li> <li><code>re_rule</code> - Define a regex-based HTTP routing rule.</li> </ul>"},{"location":"routing/#websocket-routing-functions","title":"Websocket Routing Functions","text":"<ul> <li><code>websocket</code> - Define a WebSocket routing rule.</li> </ul>"},{"location":"routing/#dynamic-routing-functions","title":"Dynamic Routing Functions","text":"<ul> <li><code>link</code> - Link schematic routing from specified modules.</li> <li><code>include</code> - Include routing configuration from specified modules.</li> </ul>"},{"location":"routing/#rule_all","title":"<code>rule_all</code>","text":"<p>Define an HTTP routing rule for all methods.</p> <ul> <li>path <code>(str)</code>: The URL path pattern.</li> <li>endpoint <code>(Callable[..., Awaitable[T]])</code>: The function to be executed for the route.</li> <li>response_model <code>(Optional[Type[T]])</code>: The response model type.</li> <li>strict_slashes <code>(bool)</code>: Whether to consider trailing slashes.</li> <li>name <code>(Optional[str])</code>: The name of the route.</li> </ul> <p>Returns: - <code>Callable[..., Awaitable[T]]</code>: The function to handle the route.</p> <pre><code>from aquilify.core.routing import rule_all\n\nROUTER = [\n    rule_all( ... )\n]\n</code></pre>"},{"location":"routing/#re_rule","title":"<code>re_rule</code>","text":"<p>Define a regex-based HTTP routing rule.</p> <ul> <li>path_regex <code>(str)</code>: The regex pattern for the URL path.</li> <li>endpoint <code>(Optional[Callable[..., Awaitable[T]]])</code>: The function to be executed for the route.</li> <li>**kwargs <code>(Any)</code>: Additional keyword arguments.</li> </ul> <p>Supported **kwargs:</p> <ul> <li>include.<ul> <li>args <code>(str)</code>: The modules' dotted paths.</li> <li>namespace <code>(str)</code>: The application namespace.</li> </ul> </li> <li>response_model <code>(Optional[Type[T]])</code>: The response model type.</li> <li>strict_slashes <code>(bool)</code>: Whether to consider trailing slashes.</li> <li>methods <code>(List[str])</code>: HTTP methods supported by the route.</li> <li>name <code>(Optional[str])</code>: The name of the route.</li> </ul> <p>Returns: - <code>Optional[List[Tuple[str, EndpointType]]]</code>: A list containing a tuple of path and endpoint.</p> <pre><code>from aquilify.core.routing import re_rule\n\nROUTER = [\n    re_rule( \"/user/\\\\d+\", ... )\n]\n</code></pre>"},{"location":"routing/#websocket","title":"<code>websocket</code>","text":"<p>Define a WebSocket routing rule.</p> <p>Args:</p> <ul> <li>path <code>(str)</code>: The URL path pattern.</li> <li>endpoint <code>(Optional[Callable[..., Awaitable[T]]])</code>: The function to be executed for the route.</li> <li>**kwargs <code>(Any)</code>: Additional keyword arguments.</li> </ul> <p>Supported **kwargs:</p> <ul> <li> <p>include.     Args:</p> <ul> <li>args <code>(str)</code>: The modules' dotted paths.</li> <li>namespace <code>(str)</code>: The application namespace.</li> </ul> </li> </ul> <pre><code>from aquilify.core.routing import websocket\n\nROUTER = [\n    websocket( \"/ws\", ... )\n]\n</code></pre>"},{"location":"routing/#path-parameters","title":"Path Parameters","text":"<p>Paths can use URI templating style to capture path components.</p> <p><pre><code>rule('/users/{username}', user)\n</code></pre> By default this will capture characters up to the end of the path or the next <code>/</code>.</p>"},{"location":"routing/#a-path-parametes-example","title":"A Path Parametes example","text":"<p>Setup a <code>poject</code> called <code>paths</code>.</p> <p>inside the <code>paths</code> open <code>routing.py</code>, and add the following line of code.</p> <pre><code>from aquilify.core.routing import rule\n\nfrom . import views\n\nROUTER = [\n    rule('/user/{user_id}', endpoint=views.home, name='Basic User verification'),\n]\n</code></pre> <p>Warning</p> <p>Currently <code>paths_params</code> not supported the types parameter due to it's complex structure, but in future this feature will be available.</p> <p><pre><code>ROUTER = [\n    rule('/user/{user_id}', endpoint=views.home, name='Basic User verification'),\n]\n</code></pre> By default this will capture characters up to the end of the path or the next <code>/</code></p>"},{"location":"routing/#pathsviewspy","title":"<code>paths/views.py</code>","text":"<pre><code>user_ids: list = []\n\nasync def home(user_id: int):\n    if user_id in user_ids:\n        return {'message': 'Verification succesfull'}, 200\n    return {'message': 'Invalid user_id'}, 403\n</code></pre> <p>Info</p> <p><code>path_parmas</code> are also been accessed using <code>request.path_params</code>.</p> <pre><code>user_ids: list = []\n\nasync def home(request):\n    if request.path_params in user_ids:\n        return {'message': 'Verification succesfull'}, 200\n    return {'message': 'Invalid user_id'}, 403\n</code></pre>"},{"location":"routing/#parametes-handler","title":"Parametes handler","text":"<p>You must have to pass the same parameter in the <code>handler</code> with passed in the <code>ROUTER[path'{}']</code> if matched fails it raise NotFound by default.</p>"},{"location":"routing/#for-example","title":"For example:","text":"<pre><code>ROUTER = [\n    rule('/user/{user_id}', endpoint=views.home, name='Basic User verification'),\n]\n\nasync def home(user_id: int):\n\n# user_id `param` name should be same a routing name.\n</code></pre>"},{"location":"routing/#handling-http-methods","title":"Handling HTTP methods","text":"<p><code>rule</code> can also specify which HTTP methods are handled by an endpoint:</p> <p><code>routing.py</code> <pre><code>rule('/user/{user_id}', endpoint=user, methods=[\"GET\", \"POST\"])\n</code></pre></p> <p>By default function endpoints will only accept <code>GET</code> requests, unless specified.</p> <p>Info</p> <p><code>Aquilify</code> only support's these HTTP Methods</p> <pre><code>SUPPORTED_METHODS = [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"TRACE\"]\n</code></pre> <p>if you pass any methods other than that, it immediately raise <code>Invalid HTTP Method</code> Exception!.</p> <p>Methods can also be in either <code>captial</code> or <code>small</code> letter's.</p>"},{"location":"routing/#route-priority","title":"Route priority","text":"<p>Incoming paths are matched against each <code>rule</code> in order.</p> <p>In cases where more that one route could match an incoming path, you should take care to ensure that more specific routes are listed before general cases.</p> <p>For example:</p> <pre><code># Don't do this: `/users/me` will never match incoming requests.\nROUTES = [\n    rule('/users/{username}', endpoint=user),\n    rule('/users/me', endpoint=current_user),\n]\n\n# Do this: `/users/me` is tested first.\nROUTES = [\n    rule('/users/me', endpoint=current_user),\n    rule('/users/{username}', endpoint=user),\n]\n</code></pre>"},{"location":"routing/#websocket-routing","title":"WebSocket Routing","text":"<p>When working with WebSocket endpoints, you should use <code>websocket</code> instead of the usual <code>rule</code>.</p> <p>Path parameters, and reverse URL lookups for <code>websocket</code> work the the same as HTTP <code>rule</code>, which can be found in the HTTP rule section above.</p> <p><code>routing.py</code> <pre><code>from aquilify.core.routing import rule, websocket\n\nfrom . import ws\n\nROUTER = [\n    websocket('/ws', endpoint=ws.websocket_endpoint),\n    websocket('/user', endpoint=ws.websocket_user)\n]\n</code></pre></p> <p>Warning</p> <p>Websockets route can't be accesible through <code>http://</code> or <code>https://</code> you may need a Websocket client such as <code>python-websockets</code> or use the standard <code>Javascript</code> Websocket to connect using <code>ws://</code> or <code>wss://</code>.</p> <p>create a new <code>ws.py</code> file inside you project.</p> <pre><code>from aquilify.wrappers import WebSocket, WebSocketDisconnect\n\nasync def websocket_endpoint(websocket: WebSocket) -&gt; WebSocket:\n    await websocket.accept()\n    try:\n        while True:\n            data = websocket.receive_text()\n            await websocket.send_text(data)\n    except WebSocketDisconnect as e:\n        raise e\n\nasync def websocket_user(websocket, name: str):\n    await websocket.accept()\n    await websocket.send_text(f\"Hello, {name}\")\n    await websocket.close()\n</code></pre> <ul> <li>An async function, which accepts <code>websocket</code> argument and <code>**path_params</code> if any.</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#writing-your-first-aquilify-app","title":"Writing your first Aquilify app \u00b6","text":"<p>Let\u2019s learn by example.</p> <p>Throughout this tutorial, we\u2019ll walk you through the creation of a basic Todo application.</p> <ul> <li>A public site that lets people view todo and vote in them.</li> </ul> <p>We\u2019ll assume you have Aquilify installed already. You can tell Aquilify is installed and which version by running the following command in a shell prompt (indicated by the $ prefix):</p> <pre><code>$ aquilify --version\n</code></pre> <p>If Aquilify is installed, you should see the version of your installation. If it isn\u2019t, you\u2019ll get an error telling \u201cNo module named aquilify.</p> <p>This tutorial is written for Aquilify 1.14, which supports Python 3.10 and later. If the Aquilify version doesn\u2019t match, you can refer to the tutorial for your version of Aquilify by using the version switcher at the bottom right corner of this page, or update Aquilify to the newest version. If you\u2019re using an older version of Python, check What Python version can I use with Aquilify? to find a compatible version of Aquilify.</p> <p>See How to install Aquilify for advice on how to remove older versions of Aquilify and install a newer one.</p> <p>Info</p> <p>Where to get help:</p> <p>If you\u2019re having trouble going through this tutorial, please head over to the Getting Help section of the FAQ.</p>"},{"location":"tutorial/#creating-a-project","title":"Creating a project \u00b6","text":"<p>If this is your first time using Aquilify, you\u2019ll have to take care of some initial setup. Namely, you\u2019ll need to auto-generate some code that establishes a Aquilify project \u2013 a collection of settings for an instance of Aquilify, Aquilify-specific options and application-specific settings.</p> <p>From the command line, cd into a directory where you\u2019d like to store your code, then run the following command:</p> <p><pre><code>$ aquilify create-app\n</code></pre> Then it ask to name you app in this case we naming todo then it ask for setup Electrus ( Optional ) either select YES or NO.</p> <p>Info</p> <p>Note</p> <p>You\u2019ll need to avoid naming projects after built-in Python or Aquilify components. In particular, this means you should avoid using names like aquilify (which will conflict with Aquilify itself) or test (which conflicts with a built-in Python package).</p> <p>Success</p> <p>Where should this code live?</p> <p>If your background is in plain old PHP (with no use of modern frameworks), you\u2019re probably used to putting code under the web server\u2019s document root (in a place such as /var/www). With Aquilify, you don\u2019t do that. It\u2019s not a good idea to put any of this Python code within your web server\u2019s document root, because it risks the possibility that people may be able to view your code over the web. That\u2019s not good for security.</p> <p>Put your code in some directory outside of the document root, such as /home/mycode.</p> <p>Let\u2019s look at what aquilify created:</p> <p><pre><code>todo/\n    app/\n        __init__.py\n        app.py\n    lifespan/\n        __init__.py\n    __init__.py\n    __root__.py\n    asgi.py\n    tools.py\n    models.py\n    settings.py\n    routing.py\n    views.py\n    packlib.lxe\n    config.cfg\n</code></pre> These files are:</p> <ul> <li> <p>The outer todo/ root directory is a container for your project. Its name doesn\u2019t matter to Aquilify you can rename it to anything you like.</p> </li> <li> <p>todo/app: A dynamic routing directory using Aquilify Schematic inside the todo/app/main.py some codes were auto generated for configuration of Schematic.</p> </li> <li> <p>todo/init.py: An empty file that tells Python that this directory should be considered a Python package. If you\u2019re a Python beginner, read more about packages in the official Python docs.</p> </li> <li> <p>todo/root.py: Main pipline for your application flow it controls the entire application inside the root.py and variable defined called instance it's the main entry-point for you application to connect with web.</p> </li> <li> <p>todo/settings.py: Settings/configuration for this Aquilify project. Aquilify settings will tell you all about how settings work.</p> </li> <li> <p>todo/routing.py: The URL declarations for this Aquilify project; a \u201ctable of contents\u201d of your Aquilify-powered site. You can read more about URLs in URL dispatcher.</p> </li> <li> <p>todo/views.py: The views.py is file where you can define all you views.</p> </li> <li> <p>todo/packlib.lxe: This file contain pipline releated to your project, if you made any further changes it may reflect to your project and maybe it broke the entire project.</p> </li> <li> <p>todo/config.cfg: This file contain data releated to your APPLICATION &amp; ASGI_SERVER there are two block do not make changes to the AQUILIFY block, and for ASGI_SERVER block by default it uses NETIX asgi web server you may configure it to either UVICORN or NETIX, support for more web server's soon...</p> </li> </ul>"},{"location":"tutorial/#the-development-server","title":"The development server\u00b6","text":"<p>Let\u2019s verify your Aquilify project works. Change into the outer todo directory, if you haven\u2019t already, and run the following commands:</p> <pre><code>$ aquilify runserver\n</code></pre> <p>You\u2019ll see the following output on the command line:</p> <pre><code>* Starting Netix v1.12 (cpython 3.11.6, linux)\n-----------------------------------------------------------------------\nOptions:\nrun(host=127.0.0.1, port=8000, reuse_port=True, worker_num=1, reload=True, app=asgi:app, log_level=DEBUG)\n-------------------------------- ---------------------------------------\n[2023-12-11 22:25:18] Starting Netix as an ASGI server for: Aquilify\n[2023-12-11 22:25:18,079] INFO: lifespan: startup\n[2023-12-11 22:25:18,080] INFO: lifespan.startup.complete\n[2023-12-11 22:25:19] Netix (ASGI) (pid 18513) is started at 127.0.0.1 port 8000\n</code></pre> <p>You\u2019ve started the Aquilify development server, a fullstack web server written purely in Python. We\u2019ve included this with Aquilify so you can develop things rapidly, without having to deal with configuring a production server \u2013 such as Apache \u2013 until you\u2019re ready for production.</p> <p>Now that the server\u2019s running, visit http://127.0.0.1:8000/ with your web browser. You\u2019ll see a \u201cCongratulations!\u201d page, with a rocket taking off. It worked!</p> <p>Success</p> <p>By default, the runserver command starts the development server on the internal IP at port 8000.</p> <p>If you want to change the server\u2019s port, open the config.cfg and inside the ASGI_SERVER block change the port. For instance, this command starts the server on port 8000:</p> <p><pre><code>[ASGI_SERVER]\nport = 8080 \n</code></pre> If you want to change the server\u2019s IP, pass it along with the port. For example, to listen on all available public IPs (which is useful if you are running Vagrant or want to show off your work on other computers on the network), use:</p> <pre><code>[ASGI_SERVER]\nhost = 0.0.0.0\n</code></pre> <p>Success</p> <p>Automatic reloading of runserver</p> <p>The development server automatically reloads Python code for each request as needed. You don\u2019t need to restart the server for code changes to take effect. However, some actions like adding files don\u2019t trigger a restart, so you\u2019ll have to restart the server in these cases.</p>"},{"location":"tutorial/#write-your-first-view","title":"Write your first view \u00b6","text":"<p>Let\u2019s write the first view. Open the file todos/views.py and put the following Python code in it:</p> <pre><code># todo/views.py\n\nasync def index():\n    return {\"message\": \"Hello, world. You're at the todo index.\"}\n</code></pre> <p>This is the simplest view possible in Aquilify. To call the view, we need to map it to a URL - and for this we need a URLconf.</p> <p>To create a URLconf in the todo directory, open a file called routing.py.</p> <p>In the todo/routing.py file include the following code:</p> <pre><code>from aquilify.core.routing import rule\n\nfrom . import views\n\nROUTER = [\n    rule('/', endpoint=views.index, name='Index Route'),\n]\n</code></pre> <p>You have now wired an index view into the URLconf. Verify it\u2019s working with the following command:</p> <pre><code>$ aquilify runserver\n</code></pre> <p>Go to http://localhost:8000/ in your browser, and you should see the text \u201cHello, world. You\u2019re at the todo index.\u201d, which you defined in the index view.</p> <p>Error</p> <p>Page not found?</p> <p>If you get an error page here, check that you\u2019re going to http://localhost:8000/ not in any other route.</p> <p>The rule() function is passed six arguments, two required: path and endpoint, and other's are optional: kwargs, and name. At this point, it\u2019s worth reviewing what these arguments are for.</p>"},{"location":"tutorial/#rule-argument-path","title":"rule() argument: path","text":"<p>path is a string that contains a URL pattern. When processing a request, Aquilify starts at the first pattern in ROUTING and makes its way down the list, comparing the requested URL against each pattern until it finds one that matches.</p>"},{"location":"tutorial/#rule-argument-endpoint","title":"rule() argument: endpoint \u00b6","text":"<p>When Aquilify finds a matching pattern, it calls the specified view function with an Request object as the first argument and any \u201ccaptured\u201d values from the route as keyword arguments. We\u2019ll give an example of this in a bit.</p> <p>Info</p> <p>Overview</p> <p>The application consists of Python code for handling CRUD operations (Create, Read, Update, Delete) for tasks. It includes functionalities to add, complete, and delete tasks.</p>"},{"location":"tutorial/#task-management","title":"Task Management:","text":"<ul> <li>TaskSchema: Defines the schema for a task using Aquilify's serializer to validate task-related data such as the task name, status, and due date.</li> <li>get_total_tasks_count(): Asynchronously retrieves the total count of tasks from the database.     CRUD Operations:</li> <li>index(request): Retrieves paginated tasks and prepares the context for rendering on the UI. It retrieves tasks based on pagination parameters (page number and items per page).</li> <li>add_task(request): Adds a new task to the database. Validates and processes task data received from the form submission.</li> <li>complete_task(task_id): Marks a specific task as completed in the database.</li> <li>delete_task(task_id): Deletes a task from the database.</li> </ul>"},{"location":"tutorial/#lets-setup-the-electrus-database","title":"Let's setup the Electrus Database.","text":"<ul> <li> <p>create a new file called db.py todo/db.py.</p> </li> <li> <p>Next add these few lines of code in you previously created todo/db.py:</p> </li> </ul> <pre><code>from electrus.asynchronous import Electrus\n\nclient = Electron()\ndb = client['Todos']\n\ntodos_collection = db['mytodo']\n</code></pre> <p>Info</p> <p>Electrus, a micro JSON Database built on Electron and written purely in Python, stands out for its simplicity, offering swift installation, seamless configuration, and rapid data processing. It efficiently stores data in JSON format, leveraging its simplicity to provide faster processing compared to SQL or ORM databases. Its user-friendly interface makes it exceptionally easy to use, making it a highly recommended choice for development purposes.</p> <p>A Basic usage:</p> <pre><code>from electrus.asynchronous  import Electrus\n\nimport asyncio\n\nclient = Electrus()\n# if your setting.py configured with the Electrus database,\n# then you don't need to pass any arguments in the Electrus() class\n\ndb = client['Test']\ncollection = db['mycollection']\n\n# basic operations...\n\nasync def main():\n    query = await collection.insert_one( {\"data\": [1234, {\"name\": \"Testuser\", \"email\": \"test@user.com\"} ] } )\n    print(query) # -&gt; return Document(**colonID) string\n\n    query = await collection.find_one( {\"_id\": \"01fc8s1f9sa0rv1s0a45fsv0S\"} )\n    print(query) # -&gt; return Document(**data) dict\n\n    query = await collection.update_one( {\"_id\": \"01fc8s1f9sa0rv1s0a45fsv0S\"}, {\"$set\": { \"new_data\": \"my_new_data\" } } )\n    print(query) # -&gt; return Document(**colonID) string\n\n    query = await collection.delete_one( {\"_id\": \"01fc8s1f9sa0rv1s0a45fsv0S\"} )\n    print(query) # -&gt; return Document(**colonID) string\n\nif __name__ == '__main__':\n    asynio.run(main())\n</code></pre> <p>With these changes you are connected with the Electrus Database. for more infor visit: http://electrus.vvfin.in/operations</p>"},{"location":"tutorial/#writing-more-views","title":"Writing more views \u00b6","text":"<p>Now let\u2019s add a few more views to todo/views.py. These views are slightly different, because they take an argument:</p> <pre><code>from typing import (\n    Any, \n    Dict, \n    List, \n    Union\n)\n\nfrom aquilify.shortcuts import render\nfrom aquilify.responses import JsonResponse\n\nfrom . import db\n\nasync def get_total_tasks_count() -&gt; int:\n    return await db.todos_collection.count_documents({})\n\nasync def index(request: Any) -&gt; JsonResponse:\n    try:\n        page_number: int = int(request.args.get('page', 1))\n        items_per_page: int = int(request.args.get('limit', 10))\n\n        total_tasks: int = await get_total_tasks_count()\n        all_tasks: List[Dict[str, Any]] = list(await db.todos_collection.fetch_all())\n\n        start_index: int = (page_number - 1) * items_per_page\n        end_index: int = start_index + items_per_page\n        paginated_tasks: List[Dict[str, Any]] = all_tasks[start_index:end_index]\n\n        context: Dict[str, Union[List[Dict[str, Any]], Dict[str, Union[int, str]]]] = {\n            \"todos\": paginated_tasks,\n            \"pagination\": {\n                \"total_tasks\": total_tasks,\n                \"page\": page_number,\n                \"limit\": items_per_page\n            }\n        }\n\n        return await render(request, 'index.html', context)\n\n    except (ValueError, KeyError) as e:\n        return JsonResponse({'error': f'Invalid page or limit value provided: {e}'}, status=400)\n    except Exception as e:\n        return JsonResponse({'error': f'Failed to fetch todos: {e}'}, status=500)\n</code></pre> <p>Info</p> <p>If you have like setup the CSRF or XSRF security add these following lines of code: <pre><code>from aquilify.decorators.csrf import protect\n\n@protect\nasync def index(request: Any) -&gt; JsonResponse:\n    try:\n        page_number: int = int(request.args.get('page', 1))\n        items_per_page: int = int(request.args.get('limit', 10))\n</code></pre></p> <p>Now let's configure the Template settings in settings.py</p> <pre><code>TEMPLATES = [\n    {\n        \"BACKEND\": \"aquilify.template.jinja2\",\n        \"DIRS\": [ os.path.join(BASE_DIR, \"templates\") ],\n        \"OPTIONS\": {\n            \"autoscape\": True,\n            \"context_processors\": [\n                \"aquilify.template.context_processors.URLContextProcessor\",\n                \"aquilify.core.messages.context_processors.Messages\",\n                \"aquilify.template.context_processors.RequestContext\"\n            ],\n            \"extensions\": [\n                \"aquilify.template.extensions.URLConstructor\"\n            ]\n        }\n    }\n]\n</code></pre> <p>Info</p> <p>if you setup CSRF then update the settings.py with these changes: <pre><code>TEMPLATES = [\n    {\n        \"BACKEND\": \"aquilify.template.jinja2\",\n        \"DIRS\": [ os.path.join(BASE_DIR, \"templates\") ],\n        \"CSRF\": \"aquilify.security.csrf.CSRF\",\n        \"OPTIONS\": {\n            \"autoscape\": True,\n            \"context_processors\": [\n                \"aquilify.template.context_processors.URLContextProcessor\",\n                \"aquilify.template.context_processors.CSRFContextView\",\n                \"aquilify.core.messages.context_processors.Messages\",\n                \"aquilify.template.context_processors.RequestContext\"\n            ],\n            \"extensions\": [\n                \"aquilify.template.extensions.URLConstructor\"\n            ]\n        }\n    }\n]\n\nCSRF = [\n    {\n        \"BACKEND\": \"aquilify.security.csrf.CSRF\",\n        \"OPTIONS\": {\n            \"secret_key\": SECRET_KEY,\n            \"ip_verification\": True,\n            \"trusted_ips\": [\"*\"],\n            \"protected_methods\": [\"POST\", \"PUT\", \"DELETE\"],\n            \"cookie_options\": {\"httponly\": True, \"secure\": True, \"samesite\": 'strict'}\n        }\n    }\n]\n</code></pre></p> <p>current Aquilify only support the jinja2 template as template engine, update the DIRS with the actual directory where you want's to park you html code.</p> <p>Now update the routing.py with the changed URLs Configuration: <pre><code>from aquilify.core.routing import rule\n\nfrom . import views\n\nROUTER = [\n    rule('/', endpoint=views.index, name='Index Route'),\n]\n</code></pre></p> <p>Now let's create a todo/templates/index.html and add the following code:</p> <p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;TODO App&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;h1&gt;TODO App&lt;/h1&gt;\n        &lt;ul class=\"task-list\"&gt;\n            {% for todo in todos %}\n            &lt;li class=\"task-item\"&gt;\n                &lt;p&gt;&lt;strong&gt;{{ todo.task }}&lt;/strong&gt;&lt;/p&gt;\n                &lt;p&gt;Status: {{ todo.status }}&lt;/p&gt;\n                &lt;p&gt;Due Date: {{ todo.due_date }}&lt;/p&gt;\n                &lt;div class=\"task-actions\"&gt;\n                    &lt;a href=\"{{ url_for('redirect', location='/complete/' + todo._id) }}\" class=\"btn btn-complete\"&gt;Complete&lt;/a&gt;\n                    &lt;a href=\"{{ url_for('redirect', location='/delete/' + todo._id) }}\" class=\"btn btn-delete\"&gt;Delete&lt;/a&gt;\n                &lt;/div&gt;\n            &lt;/li&gt;\n            {% endfor %}\n        &lt;/ul&gt;\n        &lt;div class=\"pagination\"&gt;\n            {% if pagination %}\n                {% if pagination.page &gt; 1 %}\n                    &lt;a href=\"?page={{ pagination.page - 1 }}&amp;limit={{ pagination.limit }}\"&gt;Previous&lt;/a&gt;\n                {% endif %}\n                {% for page_num in range(1, (pagination.total_tasks // pagination.limit) + 2) %}\n                    &lt;a href=\"?page={{ page_num }}&amp;limit={{ pagination.limit }}\" {% if page_num == pagination.page %}class=\"active\"{% endif %}&gt;{{ page_num }}&lt;/a&gt;\n                {% endfor %}\n                {% if pagination.page * pagination.limit &lt; pagination.total_tasks %}\n                    &lt;a href=\"?page={{ pagination.page + 1 }}&amp;limit={{ pagination.limit }}\"&gt;Next&lt;/a&gt;\n                {% endif %}\n            {% endif %}\n        &lt;/div&gt;\n        &lt;form action=\"{{ url_for('redirect', location='/add' )}}\" method=\"post\" class=\"task-form\"&gt;\n            &lt;h2&gt;Add Task&lt;/h2&gt;\n            &lt;div&gt;\n                &lt;label for=\"task\"&gt;Task:&lt;/label&gt;\n                &lt;input type=\"text\" id=\"task\" name=\"task\" required&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;label for=\"status\"&gt;Status:&lt;/label&gt;\n                &lt;input type=\"text\" id=\"status\" name=\"status\"&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;label for=\"due_date\"&gt;Due Date:&lt;/label&gt;\n                &lt;input type=\"date\" id=\"due_date\" name=\"due_date\"&gt;\n            &lt;/div&gt;\n            &lt;button type=\"submit\"&gt;Add Task&lt;/button&gt;\n        &lt;/form&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> For stylesheet visit: http://aquilify.vvfin.in/tutorial/static/stylesheet.css</p>"},{"location":"tutorial/#fetching-and-displaying-tasks","title":"Fetching and Displaying Tasks:","text":"<p>It helps display tasks (to-dos) on a web page in parts (pagination). Retrieves tasks from a database and presents a certain number of tasks per page.</p>"},{"location":"tutorial/#how-it-works","title":"How it Works:","text":"<pre><code>It receives a request containing page number and items per page information.\nRetrieves the total number of tasks available.\nGrabs the tasks for the requested page from the database.\nPrepares these tasks along with pagination details for display.\n</code></pre>"},{"location":"tutorial/#error-handling","title":"Error Handling:","text":"<pre><code>It checks for potential issues like invalid page or limit values.\nIf there are problems, it sends an error message.\nIt also catches any other unexpected errors and provides a suitable error response.\n</code></pre>"},{"location":"tutorial/#rendering-the-page","title":"Rendering the Page:","text":"<pre><code>Once everything is in order, it constructs the information needed for the web page.\nUtilizes a rendering function to display this information in an HTML template.\n</code></pre>"},{"location":"tutorial/#in-a-nutshell","title":"In a Nutshell:","text":"<pre><code>This code helps get tasks from a database and show them on a web page.\nIt manages how many tasks to display per page and handles errors that might occur during this process.\n</code></pre>"},{"location":"tutorial/#lets-add-some-more-views","title":"Let's add some more views","text":"<ul> <li>Creating a add_task view.</li> </ul> <p><pre><code>from datetime import datetime\nfrom typing import Dict, Any\n\nfrom aquilify.responses import JsonResponse\nfrom aquilify.core.backend.serializer import Schema, fields, FieldValidationError\n\nfrom . import db\n\nclass TaskSchema(Schema):\n    task: str = fields.String(required=True)\n    status: str = fields.String()\n    due_date: datetime = fields.Date()\n\nasync def add_task(request) -&gt; JsonResponse:\n    try:\n        task_data: Dict[str, Any] = await TaskSchema().loads(await request.form())\n        task_data['created_at']: str = datetime.now().strftime(\"%m/%d/%Y, %H:%M:%S\")\n\n        result: Any = await db.todos_collection.insert_one(task_data)\n        if result:\n            return JsonResponse({'message': 'Task added successfully!'})\n\n    except FieldValidationError as e:\n        return JsonResponse({'error': f'Failed to add task field: {e}'}, status=400)\n    except Exception as e:\n        return JsonResponse({'error': f'Failed to add task: {e}'}, status=500)\n</code></pre> Now update the routing.py with the updated changes: <pre><code>from aquilify.core.routing import rule\nfrom . import views\n\nROUTER = [\n    rule('/', endpoint=views.index, name='Index Route'),\n    rule('/add', endpoint=views.add_task, methods=['POST'], name='Adding Todos'),\n]\n</code></pre></p> <p>Info</p> <p>The Schema class stands at the core of the serializer functionality, allowing seamless serialization and deserialization operations through its loads and dumps functions, accepting the data argument. Notably, it offers an array of built-in fields like String, Integer, and more, streamlining the process of defining data structures and facilitating serialization effortlessly.</p> <pre><code>import asyncio\nfrom aquilify.backend.serializer import Schema, fields, FieldValidationError\n\nclass Users(Schema):\n    username = fields.String(required=True, error_messages={'required': \"Username field is required!\"})\n    email = fields.Email(required=True, error_messages={\"validation\": 'Invalid email format!'})\n    password = fields.Password(required=True, min_length=8, max_length=16, special_chars=True, error_messages={'validation': \"Invalid password format!\"})\n\nasync def main():\n# Due to it's asynchnorous nature you must have to await it.\n    data = {\n        \"username\": \"myusername\",\n        \"email\": \"demo@gmail.com\",\n        \"password\": \"demo@1234\"\n    }\n\n    result = await Users().loads(data)\n    print(result) # print the serialized data\n    result = await Users().dumps(result)\n    print(result) # print the deserialized data\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorial/#aquilify-provides-a-inbuilt-serializer-validator","title":"Aquilify provides a inbuilt serializer &amp; validator.","text":"<p>TaskSchema is a set of rules defining the structure of a task. It ensures that a task has certain attributes (task, status, due_date) and their expected data types (str, datetime, etc.). fields.String() and fields.Date() define the expected types for each attribute.</p>"},{"location":"tutorial/#adding-a-task","title":"Adding a Task:","text":"<p>This code snippet handles adding a new task to a database. It receives a request and extracts data from the form submitted in that request. Validates this data against the TaskSchema rules to ensure it meets the required structure.</p>"},{"location":"tutorial/#processing-and-saving-the-task","title":"Processing and Saving the Task:","text":"<pre><code>After validating the task data, it adds a timestamp for the task creation (created_at).\nThe current timestamp is generated using datetime.now().strftime() to represent the current date and time in a specific format (\"%m/%d/%Y, %H:%M:%S\").\nThis timestamp is added to the task data.\n</code></pre>"},{"location":"tutorial/#saving-to-the-database","title":"Saving to the Database:","text":"<pre><code>Attempts to insert the validated and timestamped task data into a database (db.todos_collection.insert_one(task_data)).\nIf successful, it returns a success message as a JsonResponse ({'message': 'Task added successfully!'}).\n</code></pre>"},{"location":"tutorial/#error-handling_1","title":"Error Handling:","text":"<pre><code>If there are validation errors (e.g., task data doesn't match TaskSchema requirements), it catches a FieldValidationError and returns an error response with a 400 status code ({'error': 'Failed to add task field: {error_message}'}).\nIf any unexpected error occurs during the addition process, it catches it as a general exception and returns a server error response with a 500 status code ({'error': 'Failed to add task: {error_message}'}).\n</code></pre>"},{"location":"tutorial/#creating-more-views","title":"Creating more views.","text":"<p><pre><code>from typing import Any\n\nfrom aquilify.responses import JsonResponse\n\nfrom . import db\n\nasync def complete_task(task_id: str) -&gt; JsonResponse:\n    try:\n        result: Any = await db.todos_collection.update_one({'_id': task_id}, {'$set': {'status': 'Completed'}})\n\n        if result:\n            return JsonResponse({'message': 'Task marked as completed!'})\n        else:\n            return JsonResponse({'error': 'Task not found!'}, status=404)\n\n    except Exception as e:\n        return JsonResponse({'error': f'Error marking task as completed: {e}'}, status=500)\n\nasync def delete_task(task_id: str) -&gt; JsonResponse:\n    try:\n        result: Any = await db.todos_collection.delete_one({'_id': task_id })\n\n        if result:\n            return JsonResponse({'message': 'Task deleted successfully!'})\n        else:\n            return JsonResponse({'error': 'Task not found!'}, status=404)\n\n    except Exception as e:\n        return JsonResponse({'error': f'Error deleting task: {e}'}, status=500)\n</code></pre> Now update the routing.py with the updated changes: <pre><code>from aquilify.core.routing import rule\nfrom . import views\n\nROUTER = [\n    rule('/', endpoint=views.index, name='Index Route'),\n    rule('/add', endpoint=views.add_task, methods=['POST'], name='Adding Todos'),\n    rule('/complete/{task_id}', endpoint=views.complete_task, name='Complete Task'),\n    rule('/delete/{task_id}', endpoint=views.delete_task, name='Delete Taks')\n]\n</code></pre></p>"},{"location":"tutorial/#steps-in-complete_task","title":"Steps in complete_task:","text":"<ul> <li> <p>Updating Task Status:     Tries to change a task's status to 'Completed' in the database using the given task_id.     Checks the result of this update.</p> </li> <li> <p>Result Check:     If the task was successfully updated, it sends a message saying the task was completed.     If the task wasn't found, it informs that the task doesn't exist.</p> </li> <li> <p>Error Handling:     If something unexpected happens during this process, it reports an error.</p> </li> </ul>"},{"location":"tutorial/#steps-in-delete_task","title":"Steps in delete_task:","text":"<ul> <li> <p>Deleting Task:     Tries to remove the task from the database using the given task_id.     Checks the result of this deletion.</p> </li> <li> <p>Result Check:     If the task was successfully deleted, it sends a message confirming the deletion.     If the task wasn't found, it indicates that the task doesn't exist.</p> </li> <li> <p>Error Handling:     If something unexpected occurs during this process, it reports an error.</p> </li> </ul> <p>Info</p> <p>This application is a fundamental example of Aquilify's capabilities. Aquilify stands out for its capacity to efficiently handle larger applications, leveraging its asynchronous nature that enables lightning-fast performance. Moreover, it excels in building robust RESTful APIs, showcasing the versatility and power of the Aquilify framework.</p>"},{"location":"tutorial/#whats-next","title":"What\u2019s next? \u00b6","text":"<p>The beginner tutorial ends here. In the meantime, you might want to check out some pointers on where to go from here.</p> <p>If you are familiar with Python packaging and interested in learning how to turn todo into a \u201creusable app\u201d, check out Advanced tutorial: How to write reusable apps.</p>"},{"location":"websocket/","title":"Websocket","text":"<p>Aquilify includes a <code>WebSocket</code> class that fulfils a similar role to the HTTP request, but that allows sending and receiving data on a websocket.</p>"},{"location":"websocket/#websocket","title":"WebSocket","text":"<p>Signature: <code>WebSocket(scope, receive=None, send=None)</code></p>"},{"location":"websocket/#real-world-example-with-aquilify-chat-app","title":"Real world example with aquilify | Chat app","text":"<p>Let's create a new project for websockets</p> <pre><code>$ aquilify create-app chat-app\n</code></pre> <p>Overview: <pre><code>chat-app/\n    templates/\n            websocket.html\n    app/\n        __init__.py\n        app.py\n    __init__.py\n    __root__.py\n    asgi.py\n    tools.py\n    models.py\n    settings.py\n    routing.py\n    views.py\n    ws.py\n    packlib.lxe\n    config.cfg\n</code></pre></p> <p>Open the chat-app/routing.py and add the following line of code:</p> <pre><code>from aquilify.core.routing import rule, websocket\n\nfrom . import views\nfrom . import ws\n\nROUTER = [\n    rule('/chat', views.homepage, name='Chatting app route'),\n    websocket('/ws', ws.websocket_endpoint)\n]\n</code></pre> <p>Next, open chat-app/views.py and the following line of code:</p> <pre><code>from aquilify.shortcuts import render\n\nasync def homepage(request):\n    return await render(request, 'chat.html')\n</code></pre> <p>Next, create a chat-app/ws.py and the following line of code:</p> <p><pre><code>import asyncio\nfrom typing import Set, Awaitable\n\nfrom aquilify.wrappers import WebSocket, WebSocketDisconnect\n\nConnectedClients = Set[WebSocket]\n\nasync def broadcast_message(message: str, connected_clients: ConnectedClients) -&gt; None:\n    tasks: Set[Awaitable[None]] = [client.send_text(message) for client in connected_clients]\n    await asyncio.gather(*tasks)\n\nasync def websocket_endpoint(websocket: WebSocket) -&gt; None:\n    connected_clients: ConnectedClients = set()\n    await websocket.accept()\n\n    try:\n        connected_clients.add(websocket)\n        while True:\n            data = await websocket.receive_text()\n            await broadcast_message(f\"Client says: {data}\", connected_clients)\n\n    except WebSocketDisconnect:\n        connected_clients.remove(websocket)\n</code></pre> Create a <code>chat-app/templates/chatapp.html</code>and add the following line of code:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;WebSocket Chat&lt;/title&gt;\n    &lt;script&gt;\n        var ws = new WebSocket(\"ws://localhost:8000/ws\");\n\n        ws.onopen = function(event) {\n            console.log(\"WebSocket connected\");\n        };\n\n        ws.onmessage = function(event) {\n            var messageBox = document.getElementById(\"messages\");\n            messageBox.innerHTML += \"&lt;p&gt;\" + event.data + \"&lt;/p&gt;\";\n        };\n\n        ws.onclose = function(event) {\n            console.log(\"WebSocket closed\");\n        };\n\n        function sendMessage() {\n            var input = document.getElementById(\"messageInput\");\n            var message = input.value;\n            ws.send(message);\n            input.value = '';\n        }\n    &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;WebSocket Chat&lt;/h1&gt;\n    &lt;div id=\"messages\"&gt;&lt;/div&gt;\n    &lt;input type=\"text\" id=\"messageInput\" /&gt;\n    &lt;button onclick=\"sendMessage()\"&gt;Send&lt;/button&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"websocket/#if-cspmiddleware-enabled","title":"If CSPMiddleware enabled","text":"<p>Don't forgot add the script-src in settings.py </p> <p><pre><code>CSP_DIRECTIVES = { \n  'default-src': [\"'self'\"],\n  'style-src': [\"'self'\", \"'unsafe-inline'\"],\n  'script-src': [\"'self'\", \"'unsafe-inline'\"] # add the script-src['unsafe-inline']\n}\n</code></pre> In according to use the Javascript inside the html, you must have to tell browser using the CSPMiddleware which is by default enabled.</p>"},{"location":"websocket/#standard-use-of-websockets","title":"Standard use of Websockets","text":"<pre><code>from aquilify.wrappers import WebSocket\n\n\nasync def app(scope, receive, send):\n    websocket = WebSocket(scope=scope, receive=receive, send=send)\n    await websocket.accept()\n    await websocket.send_text('Hello, world!')\n    await websocket.close()\n</code></pre> <p>WebSockets present a mapping interface, so you can use them in the same way as a <code>scope</code>.</p> <p>For instance: <code>websocket['path']</code> will return the ASGI path.</p>"},{"location":"websocket/#url","title":"URL","text":"<p>The websocket URL is accessed as <code>websocket.url</code>.</p> <p>The property is actually a subclass of <code>str</code>, and also exposes all the components that can be parsed out of the URL.</p> <p>For example: <code>websocket.url.path</code>, <code>websocket.url.port</code>, <code>websocket.url.scheme</code>.</p>"},{"location":"websocket/#headers","title":"Headers","text":"<p>Headers are exposed as an immutable, case-insensitive, multi-dict.</p> <p>For example: <code>websocket.headers['sec-websocket-version']</code></p>"},{"location":"websocket/#query-parameters","title":"Query Parameters","text":"<p>Query parameters are exposed as an immutable multi-dict.</p> <p>For example: <code>websocket.query_params['search']</code></p>"},{"location":"websocket/#path-parameters","title":"Path Parameters","text":"<p>Router path parameters are exposed as a dictionary interface.</p> <p>For example: <code>websocket.path_params['username']</code></p>"},{"location":"websocket/#accepting-the-connection","title":"Accepting the connection","text":"<ul> <li><code>await websocket.accept(subprotocol=None, headers=None)</code></li> </ul>"},{"location":"websocket/#sending-data","title":"Sending data","text":"<ul> <li><code>await websocket.send_text(data)</code></li> <li><code>await websocket.send_bytes(data)</code></li> <li><code>await websocket.send_json(data)</code></li> </ul> <p>JSON messages default to being sent over text data frames, from version 1.10.0 onwards. Use <code>websocket.send_json(data, mode=\"binary\")</code> to send JSON over binary data frames.</p>"},{"location":"websocket/#receiving-data","title":"Receiving data","text":"<ul> <li><code>await websocket.receive_text()</code></li> <li><code>await websocket.receive_bytes()</code></li> <li><code>await websocket.receive_json()</code></li> </ul> <p>May raise <code>aquilify.wrappers.WebSocketDisconnect()</code>.</p> <p>JSON messages default to being received over text data frames, from version 1.10.0 onwards. Use <code>websocket.receive_json(data, mode=\"binary\")</code> to receive JSON over binary data frames.</p>"},{"location":"websocket/#iterating-data","title":"Iterating data","text":"<ul> <li><code>websocket.iter_text()</code></li> <li><code>websocket.iter_bytes()</code></li> <li><code>websocket.iter_json()</code></li> </ul> <p>Similar to <code>receive_text</code>, <code>receive_bytes</code>, and <code>receive_json</code> but returns an async iterator.</p> <pre><code>from aquilify.wrappers import WebSocket\n\n\nasync def app(scope, receive, send):\n    websocket = WebSocket(scope=scope, receive=receive, send=send)\n    await websocket.accept()\n    async for message in websocket.iter_text():\n        await websocket.send_text(f\"Message text was: {message}\")\n    await websocket.close()\n</code></pre> <p>When <code>aquilify.wrappers.WebSocketDisconnect</code> is raised, the iterator will exit.</p>"},{"location":"websocket/#closing-the-connection","title":"Closing the connection","text":"<ul> <li><code>await websocket.close(code=1000, reason=None)</code></li> </ul>"},{"location":"websocket/#sending-and-receiving-messages","title":"Sending and receiving messages","text":"<p>If you need to send or receive raw ASGI messages then you should use <code>websocket.send()</code> and <code>websocket.receive()</code> rather than using the raw <code>send</code> and <code>receive</code> callables. This will ensure that the websocket's state is kept correctly updated.</p> <ul> <li><code>await websocket.send(message)</code></li> <li><code>await websocket.receive()</code></li> </ul>"}]}